package RouteGenerate;

import Common.*;
import Enumeration.RouteEnum;
import static AlgoRun.AlgoParam.*;

/*
import ilog.concert.IloException;
import ilog.concert.IloNumVar;
import ilog.cplex.IloCplex;
import static ilog.concert.IloNumVarType.Bool;
*/

import gurobi.*;
import static gurobi.GRB.IntParam.OutputFlag;

import java.text.ParseException;
import java.util.*;


public class RouteSearch {
    public  Instance instance; // 需要求解的实例
    public HashSet<HashSet<Integer>> coalSearch; // 记录不可行联盟，已经搜索和已经加入的联盟进行剪枝
    public HashSet<HashSet<Integer>> coalInitial; //Record the visited initial coalitions
    public ArrayList<Selection> twoSelect;
    public ArrayList<Integer> Members;


    public RouteSearch(Instance instance) {
        this.instance = instance;
        this.coalSearch = new HashSet<>();
        this.twoSelect = new ArrayList<>();
        this.coalInitial = new HashSet<>();
    }

    //成本分配
    public void run() throws ParseException {
        //Enumerated LTL routes and initial coalitions
        RouteEnum enmu = new RouteEnum(instance);

        if (instance.LTL_Routes.isEmpty()) {
            enmu.ENUM_LTLRoutes(0);
        }

        if (instance.TWO_Routes.isEmpty()) {
            if(instance.LIFO){
                enmu.ENUM_TwoRoutes_LIFO(instance.NUM);
            }
            else {
                enmu.ENUM_TwoRoutes(instance.NUM);
            }
        }

        //Record the usage frequency of two-member coalitions
        for (int id = 0; id < instance.TWO_Routes.size(); id++){
            Selection sel = new Selection();
            sel.ID = id; //the position of route in TWO_Routes
            sel.use = 0;
            twoSelect.add(sel);
        }

        //The LCS process
        long startTime = System.currentTimeMillis();
        initializeLCS();
        iterLCS();
        instance.TIME_LCS = (System.currentTimeMillis() - startTime)/1000.0/60;

        //Doubel check
        for (Route route : instance.LCS_Routes) {
            if (!instance.feasible(route,false)) {
                int n = route.R.size()/2 - 1;
                System.err.printf("####### The LCS route is NOT feasible: size %d, cost %.4f, load %.2f, duration %.2f ####### %n",
                        n, route.cost, route.load, route.time);
            }
        }

        //Process the final solution
        instance.routesLCS.entrySet().removeIf(route -> route.getValue().R.size() == 2);
        instance.SolutionModify(instance.routesLCS,"LCS");
        instance.subtLCS = instance.generateSubt(instance.routesLCS);
        instance.COST_LCS = instance.Calculation(instance.routesLCS);

        //Check validity
        double total = 0;
        for (int i = 1; i <= instance.NUM; i++) {
            if (Double.isNaN(instance.allocateLCS[i])) {
                System.out.printf("####### Error in exhausted allocation: %d, %.4f ####### %n",
                        i, instance.allocateLCS[i]);
            }
            total = total + instance.allocateLCS[i];
        }
        if(Math.abs(instance.COST_LCS - total) > 1e-6) {
            System.out.printf("####### The LC allocation is NOT balanced: %.4f, %.4f ####### %n",
                    instance.COST_LCS, total);
        }

        //Check stability
        double[] stb = instance.MaxDEV(instance.allocateLCS,instance.constrLCS); //eps, dev, instb
        instance.epsilon_LCS = stb[0];
        instance.MAXDEV_LCS = stb[1];
        instance.instb_LCS = stb[2];
        System.out.printf("-------- Algorithm LCS is stopped: %d iter, %.2f min, %d routes, %.4f eps-------- %n",
                instance.ITER_LCS, instance.TIME_LCS, instance.NUM_LCS, instance.epsilon_LCS);
        System.out.printf("------- Routes generated by LCS: %d 2-routes, %d 3-routes, %d 4-routes -------%n",
                instance.Two_LCS, instance.Three_LCS, instance.Four_LCS);
    }


    //Generate initial routes and constraints
    public void initializeLCS() {
        int NUM = instance.NUM;
        instance.routesLCS = new HashMap<>(); //selected routes
        instance.LCS_Routes = new HashSet<>(); //enumerated routes
        instance.constrLCS = new HashMap<>(); //generated stability constraints

        instance.LCS_Routes.addAll(instance.LTL_Routes);
        for(int i = 1 ; i <= NUM; i++){
            int[] coefficient = new int[NUM + 1];
            coefficient[0] = -1;
            coefficient[i] = 1;
            instance.constrLCS.put(coefficient,instance.SignleCost[i]);
        }

        //Add two-order routes stability
        /*instance.LCS_Routes.addAll(instance.TWO_Routes);
        for (Route route:instance.TWO_Routes) {
            int[] coefficient = new int[NUM + 1];
            coefficient[0] = -1;
            for (int i = 1; i < route.R.size() / 2; i++) {
                coefficient[route.R.get(i)] = 1;
            }
            instance.constrLCS.put(coefficient, route.cost);

            HashSet<Integer> member = new HashSet<>();
            for(int i = 1; i < route.R.size()/2; i++){
                member.add(route.R.get(i));
            }
            coalSearch.add(member);
        }*/
    }


    public void resetLCS(Double[] assignment) {
        instance.LCS_Routes = new HashSet<>(); //enumerated routes
        instance.constrLCS = new HashMap<>();
        coalSearch = new HashSet<>();

        instance.LCS_Routes.addAll(instance.LTL_Routes);
        for(int i = 1 ; i <= instance.NUM; i++){
            int[] coefficient = new int[instance.NUM + 1];
            coefficient[0] = -1;
            coefficient[i] = 1;
            instance.constrLCS.put(coefficient, instance.SignleCost[i]);
        }

        HashSet<HashSet<Integer>> coalOpt = new HashSet<>();
        for(Route route:instance.routesLCS.values()){
            HashSet<Integer> coal = new HashSet<>();
            for(int i = 1; i < route.R.size()/2; i++){
                coal.add(route.R.get(i));
            }
            coalOpt.add(coal);
        }

        double epsL = 0; //assignment[0];
        for (Route route : instance.TWO_Routes) {
            int[] coefficient = new int[instance.NUM + 1];
            coefficient[0] = -1;
            double cost_assign = 0;
            HashSet<Integer> coal = new HashSet<>();
            for (int i = 1; i < route.R.size() / 2; i++) {
                int c = route.R.get(i);
                coefficient[c] = 1;
                cost_assign = cost_assign + assignment[c];
                coal.add(c);
            }

            //remove redundant routes for stability
            if(cost_assign - route.cost >= epsL || coalOpt.contains(coal)) {
                instance.LCS_Routes.add(route);
                instance.constrLCS.put(coefficient, route.cost);
                coalSearch.add(coal);
            }
        }
        //end
        System.out.printf("Reset LCS: route size %d; constraint size %d %n",
                instance.LCS_Routes.size(), instance.constrLCS.size());
    }


    //LCS procedure
    public void iterLCS() throws ParseException {
        long startTime = System.currentTimeMillis();

        Members = new ArrayList<>();
        for (int i = 1; i <= instance.NUM; i++) {
            Members.add(i);
        }

        //the current primal optimum
        instance.routesLCS = solveOPT_Gurobi();
        instance.SolutionModify(instance.routesLCS,"LCS");
        instance.subtLCS = instance.generateSubt(instance.routesLCS);
        instance.COST_LCS = instance.Calculation(instance.routesLCS);

        //the current cost allocation
        Double[] assignment = solveCore_Gurobi();
        //reduce size of integer programs
        /*if(instance.large){
            resetLCS(assignment);
            instance.CONSTR_LCS_initial = instance.constrLCS.size();
        }*/

        //start search
        int startNum = 2, iter = 1, dev_num = 1;
        double impr = 0, gap = 100, minx = 0, maxx = 0, timeLCS = 0;
        while (dev_num > 0 && timeLCS < LCSTIME) {
            System.out.printf("---------- LCS searching at iteration %d: Searched %d, Routes %d, Constr %d----------%n",
                    iter, coalSearch.size(), instance.LCS_Routes.size(), instance.constrLCS.size());

            //optimization results
            impr = 100*(instance.OriginCost - instance.COST_LCS)/instance.OriginCost;
            System.out.printf("LCS optimization results: routes %d, COST_LCS %.4f, impr %.2f%%%n",
                    instance.routesLCS.size(), instance.COST_LCS, impr);

            //allocation results
            Double[] x = Arrays.copyOfRange(assignment, 1, instance.NUM);
            Arrays.sort(x);
            minx = x[0]; maxx = x[x.length-1];
            System.out.printf("LCS allocation: minPI %.4f, maxPI %.4f, epsilon %.4f%n", minx, maxx, assignment[0]);

            //route generation subproblem: coalSearch is updated automatically by subproblems
            Subproblem sp = new Subproblem(instance,assignment,coalSearch,twoSelect,Members,startNum);
            HashSet<Route> newRoutes = sp.run();
            dev_num = newRoutes.size();

            //Increase the size of initial routes for next search
            if (dev_num == 0 && startNum < 3) {
                startNum ++;
                dev_num = 1;
                System.out.println("######## Increase the size of initial routes and continue ########");
            }

            //update with new routes
            if (newRoutes.size() > 0) {
                for (Route route : newRoutes) {
                    //Add new routes
                    instance.LCS_Routes.add(route);

                    //Add new constraints
                    int[] coefficient = new int[instance.NUM+1];
                    coefficient[0] = -1;
                    for(int i = 1; i < route.R.size()/2; i++){
                        int cus = route.R.get(i);
                        coefficient[cus] = 1;
                    }
                    instance.constrLCS.put(coefficient, route.cost);
                }

                //new primal optimum
                instance.routesLCS = solveOPT_Gurobi();
                instance.SolutionModify(instance.routesLCS,"LCS");
                instance.subtLCS = instance.generateSubt(instance.routesLCS);
                instance.COST_LCS = instance.Calculation(instance.routesLCS);

                //new allocation
                assignment = solveCore_Gurobi();
            }

            //next iteration
            timeLCS = (System.currentTimeMillis() - startTime)/1000.0/60;
            iter ++;
        }

        //Final outcome
        instance.NUM_LCS = instance.LCS_Routes.size(); //
        for (Route route:instance.LCS_Routes) {
            if (route.R.size() <= 4) {
                continue;
            } else if (route.R.size() <= 6) {
                instance.Two_LCS ++;
            } else if (route.R.size() <= 8) {
                instance.Three_LCS ++;
            } else {
                instance.Four_LCS ++;
            }
        }

        instance.ITER_LCS = iter - 1;
        instance.allocateLCS = assignment;
    }


    //------------------------------------------Optimization problem---------------------------------------------//
    //Solve the optimization model by Gurobi
    public HashMap<Integer,Route> solveOPT_Gurobi() {
        long tt0 = System.currentTimeMillis();
        HashMap<Integer,Route> routeSol = new HashMap<>();
        int NUM = instance.NUM;

        try {
            //Index the routes
            ArrayList<Route> ROUTES = new ArrayList<>();
            //HashSet<Route> instance.LCS_Routes
            int id = 0;
            for(Route route:instance.LCS_Routes) {
                route.id = id;
                ROUTES.add(route);
                id ++;
            }

            //Setup model
            GRBEnv env = new GRBEnv();
            GRBModel model = new GRBModel(env);
            model.set(GRB.StringAttr.ModelName, "OPTIMIZATION");

            //Decision variables
            GRBVar[] x = new GRBVar[ROUTES.size()];
            for (int j = 0; j < ROUTES.size(); j++) {
                Route route = ROUTES.get(j);
                x[j] = model.addVar(0.0,1.0,route.cost,GRB.BINARY,"x" + "_" + j);
            }

            //Objective function: sum_{r}C_r*x_r
            model.set(GRB.IntAttr.ModelSense, GRB.MINIMIZE);
            /*GRBLinExpr expr = new GRBLinExpr();
            for (int j = 0; j < ROUTES.size(); j++) {
                Route route = ROUTES.get(j);
                expr.addTerm(route.cost, x[j]);
            }
            model.setObjective(expr, GRB.MINIMIZE);  */

            //Constraint matrix: a_ir
            double[][] constrMatrix = new double[NUM + 1][ROUTES.size()]; //(NUM+1) x R
            for (int j = 0; j < ROUTES.size(); j++) {
                Route route = ROUTES.get(j);
                for (int i = 1; i < route.R.size() / 2; i++) {
                    constrMatrix[route.R.get(i)][j] = 1;
                }
            }

            //Set-covering constraint: sum_{r}a_{ir}*x_{r} = 1, i = 1,...,N;
            for (int i = 1; i <= NUM; i++) {
                GRBLinExpr exprCostr = new GRBLinExpr();
                exprCostr.addTerms(constrMatrix[i], x);
                // model.addConstr(exprCostr, GRB.GREATER_EQUAL, 1.0, "cons" + i);
                model.addConstr(exprCostr, GRB.EQUAL, 1.0, "cons" + i);
            }

            //Solve the model
            model.set(GRB.IntParam.OutputFlag, 0); //no log output
            model.set("MIPGap", "1e-4");
            model.set("TimeLimit", "1800.0"); //3 min
            model.optimize();

            //Check validity of solution
            int status = model.get (GRB.IntAttr.Status);
            if (status == GRB.Status.INF_OR_UNBD || status == GRB.Status.INFEASIBLE){
                System.out.println ("###### The optimization problem is NOT feasible: " + status + " ######");
                System.exit(0);
            }

            //The solution
            for (int j = 0; j < ROUTES.size(); j++) {
                if (Math.abs(x[j].get(GRB.DoubleAttr.X) - 1) <= 1e-5) {
                    routeSol.put(ROUTES.get(j).id, ROUTES.get(j));
                }
            }

            //Optimum
            double obj = model.get(GRB.DoubleAttr.ObjVal);

            //Result
            long tt1 = System.currentTimeMillis();
            double tt = (tt1 - tt0)/1000.0;
            System.out.printf("Optimization model solved: status %s, time %.4f sec, cost %.4f %n", status, tt, obj);

            //Clear the model
            model.dispose();
            env.dispose();
        } catch (GRBException e) {
            System.err.println("Error code: " + e.getErrorCode() + ". " + e.getMessage());
        }
        return routeSol;
    }


    //------------------------------------------Cost allocation problem---------------------------------------------//
    //Solve the allocation model by Gurobi
    public Double[] solveCore_Gurobi() {
        long tt0 = System.currentTimeMillis();
        int NUM = instance.NUM;
        Double[] assignment = new Double[NUM + 1];

        try {
            //Setup model
            GRBEnv env = new GRBEnv();
            GRBModel model = new GRBModel(env);
            model.set(GRB.StringAttr.ModelName, "CORE");

            //Decision variables: pi_{i}
            GRBVar[] pi = new GRBVar[NUM + 1];
            pi[0] = model.addVar(0.0, GRB.INFINITY, 1.0, GRB.CONTINUOUS, "pi" + "_" + 0);
            for (int i = 1; i <= NUM; i++) {
                pi[i] = model.addVar(0.0, GRB.INFINITY, 0.0, GRB.CONTINUOUS, "pi" + "_" + i);
            }

            //Objective function: min pi_0
            model.set(GRB.IntAttr.ModelSense, GRB.MINIMIZE);

            //Constraints: budget balance \sum_{i>0}pi_i = cost_N
            int id = 0;
            double[] constr = new double[NUM + 1];
            constr[0] = 0;
            for (int i = 1; i <= NUM; i++) {
                constr[i] = 1;
            }
            GRBLinExpr exprB = new GRBLinExpr();
            exprB.addTerms(constr, pi);
            model.addConstr(exprB, GRB.EQUAL, instance.COST_LCS, "cons" + id);

            //Constraints: coalition stability -pi_0 + \sum_{i\in R}pi_i <= cost_R
            for (int[] ind:instance.constrLCS.keySet()) {
                id ++;
                double[] coef = Arrays.stream(ind).mapToDouble(Double::valueOf).toArray();
                GRBLinExpr exprC = new GRBLinExpr();
                exprC.addTerms(coef, pi);
                model.addConstr(exprC, GRB.LESS_EQUAL, instance.constrLCS.get(ind), "cons" + id);
            }

            //Constraints: individual rationality pi_i <= cost_i
            for (int i = 1; i <= NUM; i++) {
                id ++;
                GRBLinExpr exprI = new GRBLinExpr();
                exprI.addTerm(1, pi[i]);
                model.addConstr(exprI, GRB.LESS_EQUAL, instance.SignleCost[i], "cons" + id);
            }

            //Constraints: no free-rider pi_i >= indcosts_i
            double[] fr = new double[NUM+1]; //1 = order shipped by MSTL; 0 = otherwise
            for (Route route:instance.routesLCS.values()) {
                if (route.R.size() > 4) {
                    for (int i = 1; i < route.R.size()/2; i++) {
                        int c = route.R.get(i);
                        fr[c] = 1;
                    }
                }
            }

            for (int i = 1; i <= NUM; i++) {
                if(fr[i] > 0) {
                    Customer c_pick = instance.AllCustomers.get(i);  //pick点
                    double delay = instance.subtLCS.get(i+NUM);  //启发式求解subt，记录到deli点
                    double ci = instance.stop + c_pick.lateCost * delay * c_pick.demand;

                    GRBLinExpr exprF = new GRBLinExpr();
                    exprF.addTerm(1, pi[i]);
                    model.addConstr(exprF, GRB.GREATER_EQUAL, ci, "cons" + id);
                }
            }

            //Solve the model
            model.set(GRB.IntParam.OutputFlag, 0); //no log output
            model.set("Method", "2"); //1 = dual simplex; 2 = barrier method
            model.set("OptimalityTol", "1e-4"); //model.set("OptimalityTol", "1e-3")
            model.optimize();

            //Check validity of solution
            int status = model.get (GRB.IntAttr.Status);
            if (status == GRB.Status.INF_OR_UNBD || status == GRB.Status.INFEASIBLE){
                System.out.println ("###### The temporal allocation problem is NOT feasible: " + status + " ######");
                System.exit(0);
            }

            //The solution
            for (int j = 0; j <= NUM; j++) {
                assignment[j] = pi[j].get(GRB.DoubleAttr.X);
            }

            //Optimum
            double obj = model.get(GRB.DoubleAttr.ObjVal);

            //Result
            long tt1 = System.currentTimeMillis();
            double tt = (tt1 - tt0)/1000.0;
            System.out.printf("Allocation model solved: status %s, time %.4f sec, epsilon %.4f %n", status, tt, obj);

            //Clear the model
            model.dispose();
            env.dispose();
        } catch (GRBException e) {
            System.err.println("Error code: " + e.getErrorCode() + ". " + e.getMessage());
        }

        return assignment;
    }


    /*
    //************************************************************************************************
    //Solve the optimization model by CPlex
    public HashMap<Integer,Route> solveOPT_CPlex() throws IloException {
        long tt0 = System.currentTimeMillis();
        HashMap<Integer,Route> routeSol = new HashMap<>();

        //Index the routes
        ArrayList<Route> ROUTES = new ArrayList<>();
        //HashSet<Route> thetaRoutes = instance.LCS_Routes
        int id = 0;
        for(Route route:instance.LCS_Routes) {
            route.id = id;
            ROUTES.add(route);
            id ++;
        }

        //定义模型
        IloCplex model = null;
        try {
            model = new IloCplex();
            //定义决策变量
            IloNumVar[] X = model.numVarArray(ROUTES.size(),0,1,Bool);

            //生成系数矩阵
            int[][] constraints = new int[instance.NUM+1][ROUTES.size()];
            for (Route route:ROUTES) {
                for (int j = 1; j < route.R.size() / 2; j++) {
                    int cus = route.R.get(j); //id of the order
                    constraints[cus][route.id] = 1;
                }
            }

            //成本向量
            double[] costs = new double[ROUTES.size()];
            for (Route route:ROUTES) {
                costs[route.id] = route.cost;
            }

            //添加约束: 每个订单被服务一次
            for (int i = 1; i <= instance.NUM; i++) {
                model.addEq(model.scalProd(constraints[i],X),1); //*.addEq; *.addGe
            }

            //添加目标函数
            model.addMinimize(model.scalProd(costs,X));
            //model.setParam(IloCplex.IntParam.RootAlg, IloCplex.Algorithm.Barrier);
            model.setParam(IloCplex.DoubleParam.TimeLimit,300);
            if(instance.large){
                model.setParam(IloCplex.Param.MIP.Tolerances.MIPGap,0.01);
            } else {
                model.setParam(IloCplex.Param.MIP.Tolerances.MIPGap,1e-4);
            }
            model.setOut(null);

            if (!model.solve()) {
                System.err.println("###### The set-covering model is NOT feasible! ######");
                System.exit(0);
            }

            //记录当前解
            double[] val = model.getValues(X);
            for(int j = 0; j < val.length; j++){
                if(Math.abs(val[j] - 1) <= 1e-5){
                    routeSol.put(j, ROUTES.get(j));
                }
            }

            //end
            double tt = (System.currentTimeMillis() - tt0)/1000.0;
            System.out.printf("****** Optimization model solved at %.2f seconds with status: %s ******%n",
                    tt, model.getStatus());
            model.end();
        } catch (IloException e) {
            e.printStackTrace();
        }
        return routeSol;
    }


    public Double[] solveCore_CPlex() throws IloException {
        long tt0 = System.currentTimeMillis();
        int NUM = instance.NUM;
        Double[] assignment = new Double[NUM + 1];

        //定义模型
        IloCplex model = null;
        try {
            model = new IloCplex();
            //定义决策变量(X[0]为epsilon，X[i]为顾客i的分配成本
            IloNumVar[] X = model.numVarArray(NUM + 1, 0, Double.MAX_VALUE);

            //添加约束
            //(1) 总分配成本约束
            double[] coeff1 = new double[NUM + 1];
            coeff1[0] = 0;
            for (int i = 1; i <= NUM; i++) {
                coeff1[i] = 1;
            }
            model.addEq(model.scalProd(X, coeff1), instance.COST_LCS);

            //(2) stable 约束
            for (int[] a : instance.constrLCS.keySet()) {
                model.addLe(model.scalProd(X, a), instance.constrLCS.get(a));
            }

            //(3) 优于单独配送约束
            for (int i = 1; i <= NUM; i++) {
                model.addLe(model.prod(X[i], 1), instance.SignleCost[i]);
            }

            //(4) free-rider(避免搭便车约束）
            double[] fr = new double[NUM+1]; //1 = order shipped by MSTL; 0 = otherwise
            for(Route route:instance.routesLCS.values()){
                if (route.R.size() > 4) {
                    for (int i = 1; i < route.R.size()/2; i++) {
                        int c = route.R.get(i);
                        fr[c] = 1;
                    }
                }
            }

            for (int i = 1; i <= NUM; i++) {
                if(fr[i] > 0) {
                    Customer c_pick = instance.AllCustomers.get(i);  // pick点
                    double delay = instance.subtLCS.get(i+NUM);  // 启发式求解subt，记录到deli点
                    model.addGe(model.prod(X[i], 1), stop + c_pick.lateCost * delay * c_pick.demand);
                }
            }

            //添加目标函数
            model.addMinimize(model.prod(X[0], 1));
            //model.setParam(IloCplex.IntParam.RootAlg, IloCplex.Algorithm.Barrier);
            model.setOut(null);

            //记录当前解
            if (model.solve()) {
                double[] val = model.getValues(X);
                for (int j = 0; j < val.length; j++) {
                    assignment[j] = val[j];
                }
                //end
                double tt = (System.currentTimeMillis() - tt0)/1000.0;
                System.out.printf("******Allocation model solved at %.2f seconds with status: %s ******%n",
                        tt, model.getStatus());
            }
            model.end();

        } catch (IloException e) {
            e.printStackTrace();
        }
        return assignment;
    }
     */


}
